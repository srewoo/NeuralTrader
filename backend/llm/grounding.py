
import re
import logging
from typing import Dict, Any, List, Optional, Tuple
import pandas as pd

logger = logging.getLogger(__name__)

class GroundingEngine:
    """
    Validates LLM textual claims against real market data to mitigate hallucinations.
    """

    def __init__(self):
        # Regex to find currency amounts or numbers that look like prices
        # Matches: ₹2,500.50, 2500.50, Rs 2500, 2000
        self.price_pattern = re.compile(r'(?:₹|Rs\.?|INR)?\s?(\d+(?:,\d{3})*(?:\.\d{1,2})?)')

    def check_response(
        self,
        llm_text: str,
        context_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Main entry point to check an LLM response.
        
        Args:
            llm_text: The raw text generated by the LLM
            context_data: Dictionary containing real data (current_price, high, low, etc.)
            
        Returns:
            Dictionary with 'is_grounded' (bool), 'violations' (list), and 'corrected_text' (str)
        """
        violations = []
        
        # 1. Price Sanity Check
        # Does the text mention a price that is way off?
        price_violations = self._verify_price_claims(llm_text, context_data)
        violations.extend(price_violations)
        
        # 2. Trend Check (TODO: If text says "Bullish" but data says "Diff < -5%", flag it)
        
        is_grounded = len(violations) == 0
        corrected_text = llm_text
        
        if not is_grounded:
            # Append warnings
             warnings = "\n\n**⚠️ AI Fact-Check Warnings:**\n"
             for v in violations:
                 warnings += f"- {v}\n"
             corrected_text += warnings
             
        return {
            "is_grounded": is_grounded,
            "violations": violations,
            "corrected_text": corrected_text
        }

    def _verify_price_claims(self, text: str, data: Dict[str, Any]) -> List[str]:
        """
        Check if prices mentioned in text are within reasonable range of actual data.
        """
        violations = []
        
        current_price = data.get('current_price')
        if not current_price:
            return []
            
        # Extract potential prices from text
        # Only check prices that are clearly explicitly stated numbers
        # This is a heuristic and can have false positives, so we look for significant deviations
        
        matches = self.price_pattern.finditer(text)
        
        for match in matches:
            val_str = match.group(1).replace(',', '')
            # print(f"DEBUG: Found {val_str}")
            val_str = match.group(1).replace(',', '')
            try:
                val = float(val_str)
                
                # Heuristic: If number is within 50% of current price, treat it as a price claim
                # Otherwise it might be a year (2025) or quantity (100 shares)
                if val > (current_price * 0.5) and val < (current_price * 1.5):
                    # It's likely referring to the stock price
                    # Check if it deviates significantly (>5%) from current price 
                    # unless it's explicitly a target or historical high
                    
                    # Context check: Does the sentence mention "target", "support", "resistance", "high", "low"?
                    # If so, we skip specific "current price" validation logic as those can differ
                    # But if it looks like "currently trading at X", we check it.
                    
                    start, end = match.span()
                    # Look at surrounding context (100 chars)
                    context_window = text[max(0, start-100):min(len(text), end+100)].lower()
                    
                    if "target" in context_window or "support" in context_window or "resistance" in context_window:
                        continue
                     
                    # Strict check for "current" or "trading at"
                    # Expanded keywords: crashed to, surged to, is at, price is
                    keywords = ["current", "trading at", "price is", "price at", "crashed to", "surged to", "fell to", "rose to", "is at"]
                    if any(k in context_window for k in keywords):
                         diff_pct = abs(val - current_price) / current_price
                         if diff_pct > 0.05: # > 5% error
                             violations.append(f"Claimed price {val} deviates from actual current price {current_price} by {diff_pct*100:.1f}%")

            except ValueError:
                continue
                
        return violations

# Global instance
_grounding_engine = None

def get_grounding_engine() -> GroundingEngine:
    global _grounding_engine
    if _grounding_engine is None:
        _grounding_engine = GroundingEngine()
    return _grounding_engine
